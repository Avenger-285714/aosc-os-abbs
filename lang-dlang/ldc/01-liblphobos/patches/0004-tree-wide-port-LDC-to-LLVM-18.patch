From 5b2e3026c05f05656973d39b4becc8db6897e545 Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Fri, 22 Mar 2024 18:29:49 -0600
Subject: [PATCH 4/4] tree-wide: port LDC to LLVM 18

---
 driver/archiver.cpp                    |  4 ++++
 driver/codegenerator.cpp               |  3 ++-
 driver/targetmachine.cpp               |  4 ++--
 driver/targetmachine.h                 |  7 ++++++-
 driver/toobj.cpp                       | 13 +++++++++++--
 gen/arrays.cpp                         | 12 ++++++++++--
 gen/dibuilder.cpp                      |  5 ++++-
 gen/llvmhelpers.cpp                    | 11 ++++++++++-
 gen/ms-cxx-helper.cpp                  |  2 +-
 gen/optimizer.cpp                      | 21 ++++++++++++---------
 gen/optimizer.h                        |  8 +++++++-
 gen/pgo_ASTbased.cpp                   | 11 +++++++++--
 gen/tocall.cpp                         |  5 +++++
 gen/toconstelem.cpp                    | 10 ++++++++--
 gen/tollvm.h                           |  8 ++++++++
 gen/trycatchfinally.cpp                |  2 +-
 gen/uda.cpp                            |  4 ++++
 runtime/druntime/src/ldc/intrinsics.di |  1 +
 18 files changed, 105 insertions(+), 26 deletions(-)

diff --git a/driver/archiver.cpp b/driver/archiver.cpp
index fb54f07529..9da4850afe 100644
--- a/driver/archiver.cpp
+++ b/driver/archiver.cpp
@@ -45,7 +45,11 @@ namespace llvm_ar {
 StringRef ArchiveName;
 std::vector<const char *> Members;
 
+#if LDC_LLVM_VER < 1800
 bool Symtab = true;
+#else
+llvm::SymtabWritingMode Symtab = llvm::SymtabWritingMode::NormalSymtab;
+#endif
 bool Deterministic = true;
 bool Thin = false;
 
diff --git a/driver/codegenerator.cpp b/driver/codegenerator.cpp
index 81fb72bd8a..b4ec07f2ad 100644
--- a/driver/codegenerator.cpp
+++ b/driver/codegenerator.cpp
@@ -24,6 +24,7 @@
 #include "gen/logger.h"
 #include "gen/modules.h"
 #include "gen/runtime.h"
+#include "gen/tollvm.h"
 #include "ir/irdsymbol.h"
 #if LDC_LLVM_VER >= 1400
 #include "llvm/IR/DiagnosticInfo.h"
@@ -114,7 +115,7 @@ void emitLLVMUsedArray(IRState &irs) {
     return;
   }
 
-  auto *i8PtrType = llvm::Type::getInt8PtrTy(irs.context());
+  auto *i8PtrType = LDC_getInt8PtrTy(irs.context());
 
   // Convert all elements to i8* (the expected type for llvm.used)
   for (auto &elem : irs.usedArray) {
diff --git a/driver/targetmachine.cpp b/driver/targetmachine.cpp
index 6aee1d199a..fcb00747aa 100644
--- a/driver/targetmachine.cpp
+++ b/driver/targetmachine.cpp
@@ -437,7 +437,7 @@ createTargetMachine(const std::string targetTriple, const std::string arch,
                     FloatABI::Type &floatABI,
                     llvm::Optional<llvm::Reloc::Model> relocModel,
                     llvm::Optional<llvm::CodeModel::Model> codeModel,
-                    const llvm::CodeGenOpt::Level codeGenOptLevel,
+                    const llvm::CodeGenOptLevel codeGenOptLevel,
                     const bool noLinkerStripDead) {
   // Determine target triple. If the user didn't explicitly specify one, use
   // the one set at LLVM configure time.
@@ -652,7 +652,7 @@ createTargetMachine(const std::string targetTriple, const std::string arch,
 
   return target->createTargetMachine(triple.str(), cpu, finalFeaturesString,
                                      targetOptions, relocModel, codeModel,
-                                     codeGenOptLevel);
+                                     static_cast<llvm::CodeGenOptLevel>(codeGenOptLevel));
 }
 
 ComputeBackend::Type getComputeTargetType(llvm::Module* m) {
diff --git a/driver/targetmachine.h b/driver/targetmachine.h
index ce7f398f4d..3bfa567e4f 100644
--- a/driver/targetmachine.h
+++ b/driver/targetmachine.h
@@ -27,6 +27,11 @@ template <typename T> using Optional = std::optional<T>;
 #include "llvm/Support/CodeGen.h"
 #include <string>
 #include <vector>
+namespace llvm {
+#if LDC_LLVM_VER < 1800
+using CodeGenOptLevel = llvm::CodeGenOpt::Level;
+#endif
+}
 
 namespace ExplicitBitness {
 enum Type { None, M32, M64 };
@@ -66,7 +71,7 @@ createTargetMachine(std::string targetTriple, std::string arch, std::string cpu,
                     FloatABI::Type &floatABI,
                     llvm::Optional<llvm::Reloc::Model> relocModel,
                     llvm::Optional<llvm::CodeModel::Model> codeModel,
-                    llvm::CodeGenOpt::Level codeGenOptLevel,
+                    llvm::CodeGenOptLevel codeGenOptLevel,
                     bool noLinkerStripDead);
 
 /**
diff --git a/driver/toobj.cpp b/driver/toobj.cpp
index 39e43b9daf..e1f492fbcf 100644
--- a/driver/toobj.cpp
+++ b/driver/toobj.cpp
@@ -47,6 +47,12 @@
 
 using CodeGenFileType = llvm::CodeGenFileType;
 
+#if LDC_LLVM_VER >= 1800
+#define CGFT_AssemblyFile CodeGenFileType::AssemblyFile
+#define CGFT_ObjectFile CodeGenFileType::ObjectFile
+#define CGFT_Null CodeGenFileType::Null
+#endif
+
 #if LDC_LLVM_VER < 1700
 static llvm::cl::opt<bool>
     NoIntegratedAssembler("no-integrated-as", llvm::cl::ZeroOrMore,
@@ -127,8 +133,11 @@ void codegenModule(llvm::TargetMachine &Target, llvm::Module &m,
           nullptr,  // DWO output file
           // Always generate assembly for ptx as it is an assembly format
           // The PTX backend fails if we pass anything else.
-          (cb == ComputeBackend::NVPTX) ? CGFT_AssemblyFile : fileType,
-          codeGenOptLevel())) {
+          (cb == ComputeBackend::NVPTX) ? CGFT_AssemblyFile : fileType
+#if LDC_LLVM_VER < 1700
+          , codeGenOptLevel()
+#endif
+      )) {
     llvm_unreachable("no support for asm output");
   }
 
diff --git a/gen/arrays.cpp b/gen/arrays.cpp
index 90b149819d..4085b36d47 100644
--- a/gen/arrays.cpp
+++ b/gen/arrays.cpp
@@ -27,6 +27,8 @@
 #include "gen/tollvm.h"
 #include "ir/irfunction.h"
 #include "ir/irmodule.h"
+#include <llvm/Analysis/ConstantFolding.h>
+#include <llvm/IR/Constant.h>
 
 static void DtoSetArray(DValue *array, DValue *rhs);
 
@@ -554,8 +556,14 @@ llvm::Constant *arrayLiteralToConst(IRState *p, ArrayLiteralExp *ale) {
   for (unsigned i = 0; i < ale->elements->length; ++i) {
     llvm::Constant *val = toConstElem(indexArrayLiteral(ale, i), p);
     // extend i1 to i8
-    if (val->getType()->isIntegerTy(1))
-      val = llvm::ConstantExpr::getZExt(val, LLType::getInt8Ty(p->context()));
+    if (val->getType()->isIntegerTy(1)) {
+      LLType *I8PtrTy = LLType::getInt8Ty(p->context());
+#if LDC_LLVM_VER < 1800
+      val = llvm::ConstantExpr::getZExt(val, I8PtrTy);
+#else
+      val = llvm::ConstantFoldCastOperand(llvm::Instruction::ZExt, val, I8PtrTy, *gDataLayout);
+#endif
+    }
     if (!elementType) {
       elementType = val->getType();
     } else {
diff --git a/gen/dibuilder.cpp b/gen/dibuilder.cpp
index 9836983c6c..3e3917bf8a 100644
--- a/gen/dibuilder.cpp
+++ b/gen/dibuilder.cpp
@@ -620,13 +620,16 @@ DIType DIBuilder::CreateCompositeType(Type *t) {
   const auto elemsArray = DBuilder.getOrCreateArray(elems);
 
   DIType ret;
+  const auto runtimeLang = 0;
   if (t->ty == TY::Tclass) {
     ret = DBuilder.createClassType(
         scope, name, file, lineNum, sizeInBits, alignmentInBits,
         classOffsetInBits, DIFlags::FlagZero, derivedFrom, elemsArray,
+#if LDC_LLVM_VER >= 1800
+        runtimeLang,
+#endif
         vtableHolder, templateParams, uniqueIdentifier);
   } else {
-    const auto runtimeLang = 0;
     ret = DBuilder.createStructType(scope, name, file, lineNum, sizeInBits,
                                     alignmentInBits, DIFlags::FlagZero,
                                     derivedFrom, elemsArray, runtimeLang,
diff --git a/gen/llvmhelpers.cpp b/gen/llvmhelpers.cpp
index f3a218a8fe..f5ad484b40 100644
--- a/gen/llvmhelpers.cpp
+++ b/gen/llvmhelpers.cpp
@@ -45,6 +45,8 @@
 #include "llvm/Support/ManagedStatic.h"
 #include "llvm/Target/TargetMachine.h"
 #include "llvm/Transforms/Utils/ModuleUtils.h"
+#include <llvm/IR/Constant.h>
+#include <llvm/Analysis/ConstantFolding.h>
 #include <stack>
 
 llvm::cl::opt<llvm::GlobalVariable::ThreadLocalMode> clThreadModel(
@@ -1139,7 +1141,6 @@ LLConstant *DtoConstExpInit(const Loc &loc, Type *targetType, Expression *exp) {
 
   LLType *llType = val->getType();
   LLType *targetLLType = DtoMemType(baseTargetType);
-
   // shortcut for zeros
   if (val->isNullValue())
     return llvm::Constant::getNullValue(targetLLType);
@@ -1147,7 +1148,11 @@ LLConstant *DtoConstExpInit(const Loc &loc, Type *targetType, Expression *exp) {
   // extend i1 to i8
   if (llType->isIntegerTy(1)) {
     llType = LLType::getInt8Ty(gIR->context());
+#if LDC_LLVM_VER < 1800
     val = llvm::ConstantExpr::getZExt(val, llType);
+#else
+    val = llvm::ConstantFoldCastOperand(llvm::Instruction::ZExt, val, llType, *gDataLayout);
+#endif
   }
 
   if (llType == targetLLType)
@@ -1211,7 +1216,11 @@ LLConstant *DtoConstExpInit(const Loc &loc, Type *targetType, Expression *exp) {
            "On initializer integer type mismatch, the target should be wider "
            "than the source.");
 
+#if LDC_LLVM_VER < 1800
     return llvm::ConstantExpr::getZExtOrBitCast(val, target);
+#else
+    return llvm::ConstantFoldCastOperand(llvm::Instruction::ZExt, val, target, *gDataLayout);
+#endif
   }
 
   Logger::println("Unhandled type mismatch, giving up.");
diff --git a/gen/ms-cxx-helper.cpp b/gen/ms-cxx-helper.cpp
index b66bc0cffd..038cd6e28a 100644
--- a/gen/ms-cxx-helper.cpp
+++ b/gen/ms-cxx-helper.cpp
@@ -187,7 +187,7 @@ llvm::GlobalVariable *getTypeDescriptor(IRState &irs, ClassDeclaration *cd) {
   llvm::Constant *Fields[] = {
       classInfoPtr, // VFPtr
       llvm::ConstantPointerNull::get(
-          LLType::getInt8PtrTy(gIR->context())), // Runtime data
+          LDC_getInt8PtrTy(gIR->context())), // Runtime data
       llvm::ConstantDataArray::getString(gIR->context(), TypeNameString)};
   llvm::StructType *TypeDescriptorType =
       getTypeDescriptorType(irs, classInfoPtr, TypeNameString);
diff --git a/gen/optimizer.cpp b/gen/optimizer.cpp
index c7902aaf58..b8c8b8dd07 100644
--- a/gen/optimizer.cpp
+++ b/gen/optimizer.cpp
@@ -147,15 +147,15 @@ bool willCrossModuleInline() {
 
 bool isOptimizationEnabled() { return optimizeLevel != 0; }
 
-llvm::CodeGenOpt::Level codeGenOptLevel() {
+llvm::CodeGenOptLevel codeGenOptLevel() {
   // Use same appoach as clang (see lib/CodeGen/BackendUtil.cpp)
   if (optLevel() == 0) {
-    return llvm::CodeGenOpt::None;
+    return llvm::CodeGenOptLevel::None;
   }
   if (optLevel() >= 3) {
-    return llvm::CodeGenOpt::Aggressive;
+    return llvm::CodeGenOptLevel::Aggressive;
   }
-  return llvm::CodeGenOpt::Default;
+  return llvm::CodeGenOptLevel::Default;
 }
 
 std::unique_ptr<TargetLibraryInfoImpl> createTLII(llvm::Module &M) {
@@ -505,7 +505,13 @@ static void addPGOPasses(ModulePassManager &mpm,
     options.NoRedZone = global.params.disableRedZone;
     if (global.params.datafileInstrProf)
       options.InstrProfileOutput = global.params.datafileInstrProf;
-    mpm.addPass(InstrProfiling(options));
+    mpm.addPass(
+#if LDC_LLVM_VER < 1800
+      InstrProfiling(options)
+#else
+      InstrProfilingLoweringPass(options)
+#endif // LDC_LLVM_VER < 1800
+    );
   } else if (opts::isUsingASTBasedPGOProfile()) {
     // We are generating code with PGO profile information available.
     // Do indirect call promotion from -O1
@@ -732,12 +738,9 @@ void runOptimizationPasses(llvm::Module *M) {
     mpm = pb.buildO0DefaultPipeline(level, opts::isUsingLTO());
 #if LDC_LLVM_VER >= 1700
   } else if (opts::ltoFatObjects && opts::isUsingLTO()) {
-    mpm = pb.buildFatLTODefaultPipeline(level
-#if LDC_LLVM_VER < 1800
-                                        ,
+    mpm = pb.buildFatLTODefaultPipeline(level,
                                         opts::isUsingThinLTO(),
                                         opts::isUsingThinLTO()
-#endif
     );
 #endif
   } else if (opts::isUsingThinLTO()) {
diff --git a/gen/optimizer.h b/gen/optimizer.h
index 0b3da829fb..8877c3d796 100644
--- a/gen/optimizer.h
+++ b/gen/optimizer.h
@@ -19,6 +19,12 @@
 
 #include "llvm/Support/CommandLine.h"
 
+namespace llvm {
+#if LDC_LLVM_VER < 1800
+using CodeGenOptLevel = llvm::CodeGenOpt::Level;
+#endif
+}
+
 namespace llvm {
 class raw_ostream;
 }
@@ -39,7 +45,7 @@ unsigned optLevel();
 
 bool isOptimizationEnabled();
 
-llvm::CodeGenOpt::Level codeGenOptLevel();
+llvm::CodeGenOptLevel codeGenOptLevel();
 
 void verifyModule(llvm::Module *m);
 
diff --git a/gen/pgo_ASTbased.cpp b/gen/pgo_ASTbased.cpp
index 2f1900f01c..b2010ba013 100644
--- a/gen/pgo_ASTbased.cpp
+++ b/gen/pgo_ASTbased.cpp
@@ -40,6 +40,13 @@ llvm::cl::opt<bool, false, opts::FlagParser<bool>> enablePGOIndirectCalls(
     llvm::cl::init(true));
 }
 
+#if LDC_LLVM_VER >= 1800
+namespace llvm::support {
+  const auto little = llvm::endianness::little;
+  const auto big = llvm::endianness::big;
+}
+#endif
+
 /// \brief Stable hasher for PGO region counters.
 ///
 /// PGOHash produces a stable hash of a given function's control flow.
@@ -903,7 +910,7 @@ void CodeGenPGO::emitCounterIncrement(const RootObject *S) const {
   assert(counter_it != (*RegionCounterMap).end() &&
          "Statement not found in PGO counter map!");
   unsigned counter = counter_it->second;
-  auto *I8PtrTy = llvm::Type::getInt8PtrTy(gIR->context());
+  auto *I8PtrTy = LDC_getInt8PtrTy(gIR->context());
   gIR->ir->CreateCall(GET_INTRINSIC_DECL(instrprof_increment),
                       {llvm::ConstantExpr::getBitCast(FuncNameVar, I8PtrTy),
                        gIR->ir->getInt64(FunctionHash),
@@ -1111,7 +1118,7 @@ void CodeGenPGO::valueProfile(uint32_t valueKind, llvm::Instruction *valueSite,
     if (ptrCastNeeded)
       value = gIR->ir->CreatePtrToInt(value, gIR->ir->getInt64Ty());
 
-    auto *i8PtrTy = llvm::Type::getInt8PtrTy(gIR->context());
+    auto *i8PtrTy = LDC_getInt8PtrTy(gIR->context());
     llvm::Value *Args[5] = {
         llvm::ConstantExpr::getBitCast(FuncNameVar, i8PtrTy),
         gIR->ir->getInt64(FunctionHash), value, gIR->ir->getInt32(valueKind),
diff --git a/gen/tocall.cpp b/gen/tocall.cpp
index bbe7d373b6..3471ad73a5 100644
--- a/gen/tocall.cpp
+++ b/gen/tocall.cpp
@@ -31,6 +31,7 @@
 #include "ir/irfunction.h"
 #include "ir/irtype.h"
 #include "llvm/IR/LLVMContext.h"
+#include <llvm/IR/DerivedTypes.h>
 
 ////////////////////////////////////////////////////////////////////////////////
 
@@ -264,7 +265,11 @@ static LLType *getPtrToAtomicType(LLType *type) {
   case 32:
   case 64:
   case 128:
+#if LDC_LLVM_VER < 1800
     return LLType::getIntNPtrTy(gIR->context(), static_cast<unsigned>(N));
+#else
+    return llvm::PointerType::get(gIR->context(), static_cast<unsigned>(N));
+#endif
   default:
     return nullptr;
   }
diff --git a/gen/toconstelem.cpp b/gen/toconstelem.cpp
index c681804af3..3dd278840d 100644
--- a/gen/toconstelem.cpp
+++ b/gen/toconstelem.cpp
@@ -24,6 +24,8 @@
 #include "ir/irfunction.h"
 #include "ir/irtypeclass.h"
 #include "ir/irtypestruct.h"
+#include <llvm/Analysis/ConstantFolding.h>
+#include <llvm/IR/Constant.h>
 
 /// Emits an LLVM constant corresponding to the expression (or an error if
 /// impossible).
@@ -575,8 +577,12 @@ public:
             LLConstant *c = toConstElem(elem, p);
             // extend i1 to i8
             if (c->getType()->isIntegerTy(1)) {
-              c = llvm::ConstantExpr::getZExt(c,
-                                              LLType::getInt8Ty(p->context()));
+              LLType *I8PtrTy = LLType::getInt8Ty(p->context());
+#if LDC_LLVM_VER < 1800
+              c = llvm::ConstantExpr::getZExt(c, I8PtrTy);
+#else
+              c = llvm::ConstantFoldCastOperand(llvm::Instruction::ZExt, c, I8PtrTy, *gDataLayout);
+#endif
             }
             varInits[e->sd->fields[i]] = c;
           }
diff --git a/gen/tollvm.h b/gen/tollvm.h
index cdfbdcf1a6..15fbb77be2 100644
--- a/gen/tollvm.h
+++ b/gen/tollvm.h
@@ -217,3 +217,11 @@ void DtoMemCpy(LLType *type, LLValue *dst, LLValue *src, bool withPadding = fals
  * Generates a call to C memcmp.
  */
 LLValue *DtoMemCmp(LLValue *lhs, LLValue *rhs, LLValue *nbytes);
+
+inline auto *LDC_getInt8PtrTy(llvm::LLVMContext &C) {
+#if LDC_LLVM_VER < 1800
+    return llvm::Type::getInt8PtrTy(C);
+#else
+    return llvm::PointerType::getUnqual(C);
+#endif
+}
diff --git a/gen/trycatchfinally.cpp b/gen/trycatchfinally.cpp
index 4b6dfe0596..db7dddfcb8 100644
--- a/gen/trycatchfinally.cpp
+++ b/gen/trycatchfinally.cpp
@@ -663,7 +663,7 @@ TryCatchFinallyScopes::getLandingPadRef(CleanupCursor scope) {
 
 namespace {
   llvm::LandingPadInst *createLandingPadInst(IRState &irs) {
-    LLType *retType = LLStructType::get(LLType::getInt8PtrTy(irs.context()),
+    LLType *retType = LLStructType::get(LDC_getInt8PtrTy(irs.context()),
                                         LLType::getInt32Ty(irs.context()));
     if (!irs.func()->hasLLVMPersonalityFn()) {
       irs.func()->setLLVMPersonalityFn(
diff --git a/gen/uda.cpp b/gen/uda.cpp
index c835126c9c..b04dde1713 100644
--- a/gen/uda.cpp
+++ b/gen/uda.cpp
@@ -439,7 +439,11 @@ bool parseCallingConvention(llvm::StringRef name,
           .Case("intel_ocl_bicc", llvm::CallingConv::Intel_OCL_BI)
           .Case("x86_64_sysvcc", llvm::CallingConv::X86_64_SysV)
           .Case("win64cc", llvm::CallingConv::Win64)
+#if LDC_LLVM_VER >= 1800
+          .Case("webkit_jscc", llvm::CallingConv::WASM_EmscriptenInvoke)
+#else
           .Case("webkit_jscc", llvm::CallingConv::WebKit_JS)
+#endif
           .Case("anyregcc", llvm::CallingConv::AnyReg)
           .Case("preserve_mostcc", llvm::CallingConv::PreserveMost)
           .Case("preserve_allcc", llvm::CallingConv::PreserveAll)
diff --git a/runtime/druntime/src/ldc/intrinsics.di b/runtime/druntime/src/ldc/intrinsics.di
index 855211b54c..5737bec4af 100644
--- a/runtime/druntime/src/ldc/intrinsics.di
+++ b/runtime/druntime/src/ldc/intrinsics.di
@@ -28,6 +28,7 @@ else version (LDC_LLVM_1500) enum LLVM_version = 1500;
 else version (LDC_LLVM_1600) enum LLVM_version = 1600;
 else version (LDC_LLVM_1700) enum LLVM_version = 1700;
 else version (LDC_LLVM_1800) enum LLVM_version = 1800;
+else version (LDC_LLVM_1801) enum LLVM_version = 1801;
 else static assert(false, "LDC LLVM version not supported");
 
 enum LLVM_atleast(int major) = (LLVM_version >= major * 100);
-- 
2.44.0

